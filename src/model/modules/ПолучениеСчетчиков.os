// ----------------------------------------------------------
// This Source Code Form is subject to the terms of the
// Mozilla Public License, v.2.0. If a copy of the MPL
// was not distributed with this file, You can obtain one
// at http://mozilla.org/MPL/2.0/.
// ----------------------------------------------------------
// Codebase: https://github.com/ArKuznetsov/iracli/
// ----------------------------------------------------------

Перем ПараметрыСчетчиков;  // - Структура   - настройки счетчиков по типам объектов (см. ПараметрыСчетчиков())

#Область ПрограммныйИнтерфейс

// Процедура инициализирует получение счетчиков
//
Процедура Инициализировать() Экспорт

	УстановитьПараметрыСчетчиков();
	
КонецПроцедуры // Инициализировать()

// Процедура устанавливает параметры счетчиков
//
// Параметры:
//   НовыеПараметры     - Строка,     - путь к файлу настроек счетчиков
//                        Структура     или структура настроек счетчиков (см. ПараметрыСчетчиков())
//
Процедура УстановитьПараметрыСчетчиков(Знач НовыеПараметры = Неопределено) Экспорт
	
	Если ТипЗнч(НовыеПараметры) = Тип("Структура") Тогда
		ПараметрыСчетчиков = НовыеПараметры;
	ИначеЕсли ТипЗнч(НовыеПараметры) = Тип("Строка") Тогда
		ПараметрыСчетчиков = ОбщегоНазначения.ПрочитатьДанныеИзМакетаJSON(НовыеПараметры);
	Иначе
		ПараметрыСчетчиков = ОбщегоНазначения.ПрочитатьДанныеИзМакетаJSON("/config/counters", Истина);
	КонецЕсли;

КонецПроцедуры // УстановитьПараметрыСчетчиков()

// Функция - возвращает структуру параметров счетчиков
// (см. ../../config/counters.json)
//
// Возвращаемое значение:
//   Соответствие     - структура параметров счетчиков
//     * <тип объектов>            - Строка                     - параметры счетчиков для объектов указанного типа
//       ** counter_prefix            - Строка                     - текстовый префикс счетчиков
//       ** dimentions                - Соответствие               - доступные измерения счетчиков
//         *** <имя измерения>          - Соответствие               - описание доступного измерения счетчиков
//           **** name                    - Строка                     - имя измерения
//           **** name_rac                - Строка                     - имя, как оно возвращается утилитой RAC
//           **** description             - Строка                     - текстовое описание измерения
//       ** counters                  - Соответствие               - описание доступных счетчиков
//         *** <имя счетчика>           - Соответствие               - описание доступного счетчика
//           **** use                     - Булево                     - флаг использования счетчика
//           **** name                    - Строка                     - имя счетчика
//           **** description             - Булево                     - текстовое описание счетчика
//           **** dimentions              - Массив из Строка           - имена измерений счетчика из доступных
//           **** aggregate               - Строка                     - агрегатная функция (см. АгрегатныеФункции())
//
Функция ПараметрыСчетчиков() Экспорт
	
	Возврат ПараметрыСчетчиков;

КонецФункции // ПараметрыСчетчиков()

// Функция - возвращает описание доступных счетчиков для указанного типа объектов кластера
//           или всех доступных счетчиков
//
// Параметры:
//   ТипОбъектов     - Перечисление.РежимыАдминистрирования     - тип объектов кластера
//
// Возвращаемое значение:
//   Структура     - описание доступных счетчиков
//
Функция Список(Знач ТипОбъектов = Неопределено) Экспорт

	Счетчики = Новый Соответствие();

	Для Каждого ТекРаздел Из ПараметрыСчетчиков() Цикл

		Если ЗначениеЗаполнено(ТипОбъектов) И НЕ ВРег(ТекРаздел.Ключ) = ВРег(ТипОбъектов) Тогда
			Продолжить;
		КонецЕсли;

		Счетчики.Вставить(ТекРаздел.Ключ, Новый Соответствие());
		
		РазделСчетчиков = Счетчики[ТекРаздел.Ключ];
		СчетчикиРаздела = ТекРаздел.Значение["counters"];

		Если СчетчикиРаздела = Неопределено Тогда
			Продолжить;
		КонецЕсли;

		Для Каждого ТекСчетчик Из СчетчикиРаздела Цикл
			Если НЕ ТекСчетчик.Значение["use"] Тогда
				Продолжить;
			КонецЕсли;
			РазделСчетчиков.Вставить(ТекСчетчик.Ключ, ТекСчетчик.Значение);
		КонецЦикла;

	КонецЦикла;

	Возврат Счетчики;

КонецФункции // Список()

// Функция - возвращает значения счетчиков для переданного списка объектов
//
// Параметры:
//   Объекты           - Массив из Соответствие                 - коллекция описаний объектов для получения счетчиков
//   ТипОбъектов       - Перечисления.РежимыАдминистрирования   - тип объектов кластера
//   Счетчик           - Строка                                 - имя получаемого счетчика, если не указано,
//                                                                то получаем все счетчики
//   ПервыеКоличество  - Число                                  - количество первых, максимальных значения счетчиков,
//                                                                если 0, то получаем все значения
//   Измерения         - Строка                                 - список получаемых измерений счетчика, разделенный ","
//   АгрегатнаяФункция - Строка                                 - функция свертки значений счетчиков
//                                                                (см. АгрегатныеФункции())
//   ФорматСчетчиков   - Строка                                 - формат результата (json|prometheus|plain)
//
// Возвращаемое значение:
//   Строка     - значения счетчиков
//
Функция Счетчики(Знач Объекты,
	             Знач ТипОбъектов,
	             Знач Счетчик = "",
	             Знач ПервыеКоличество = 0,
	             Знач Измерения = "",
	             Знач АгрегатнаяФункция = "count",
	             Знач ФорматСчетчиков = "json") Экспорт

	ПараметрыСчетчиковОбъекта = ПараметрыСчетчиков()[ТипОбъектов];

	Счетчики = ЗначенияСчетчиков(Объекты, ПараметрыСчетчиковОбъекта, Счетчик);

	Если ЗначениеЗаполнено(Измерения) Тогда
		Для Каждого ТекЭлемент Из Счетчики Цикл
			ТекЭлемент.Значение["values"] = АгрегироватьЗначенияСчетчика(ТекЭлемент.Значение["values"],
			                                                             Измерения,
			                                                             АгрегатнаяФункция);
		КонецЦикла;
	КонецЕсли;

	Для Каждого ТекЭлемент Из Счетчики Цикл
		Если НЕ ЗначениеЗаполнено(ТекЭлемент.Значение["values"]) Тогда
			ТекЭлемент.Значение["values"] = Новый Массив();
			ТекЭлемент.Значение["values"].Добавить(Новый Соответствие());
			ТекЭлемент.Значение["values"][0].Вставить("_value", Неопределено);
		КонецЕсли;
	КонецЦикла;
	
	Если ПервыеКоличество > 0 Тогда
		Для Каждого ТекЭлемент Из Счетчики Цикл
			ТекЭлемент.Значение["values"] = ОбщегоНазначения.ПервыеПоЗначениюПоля(ТекЭлемент.Значение["values"],
			                                                                      "_value",
			                                                                      ПервыеКоличество);
		КонецЦикла;
	КонецЕсли;

	ПрефиксСчетчиков = ПараметрыСчетчиковОбъекта["counter_prefix"];

	Если ВРег(ФорматСчетчиков) = ФорматыРезультата().json Тогда
		Возврат ФорматJSON(Счетчики, ПрефиксСчетчиков);
	ИначеЕсли ВРег(ФорматСчетчиков) = ФорматыРезультата().prometheus Тогда
		Возврат ФорматPrometheus(Счетчики, ПрефиксСчетчиков);
	ИначеЕсли ВРег(ФорматСчетчиков) = ФорматыРезультата().plain Тогда
		Возврат ФорматPlain(Счетчики, ПрефиксСчетчиков);
	Иначе
		Возврат "";
	КонецЕсли;

КонецФункции // Счетчики()

#КонецОбласти // ПрограммныйИнтерфейс

#Область СлужебныеПроцедурыИФункции

// Функция - выполняет свертку значений счетчиков с указанным результирующим набором измерений
// и применением указанной агрегатной функции к значениям счетчиков
//
// Параметры:
//   ЗначенияСчетчика           - Массив из Соответствие   - коллекция описаний объектов для получения счетчиков
//   РезультирующиеИзмерения    - Строка, Массив           - список измерений, попадающих в результат
//   АгрегатнаяФункция          - Строка                   - агрегатная функция (см. АгрегатныеФункции())
//
// Возвращаемое значение:
//   Массив из Соответствие                        - свернутые значения счетчиков
//     * <Имя измерения>    - Строка                 - значение измерения счетчика
//     * _value             - Число, Дата, Булево    - значение счетчика
//
Функция АгрегироватьЗначенияСчетчика(ЗначенияСчетчика,
                                     Знач РезультирующиеИзмерения = "",
                                     Знач АгрегатнаяФункция = "count")

	Если ТипЗнч(РезультирующиеИзмерения) = Тип("Строка") Тогда
		Измерения = СтрРазделить(РезультирующиеИзмерения, ",", Ложь);
		Для й = 0 По Измерения.ВГраница() Цикл
			Измерения[й] = СокрЛП(Измерения[й]);
		КонецЦикла;
	ИначеЕсли ТипЗнч(РезультирующиеИзмерения) = Тип("Массив") Тогда
		Измерения = РезультирующиеИзмерения;
	Иначе
		Измерения = Новый Массив();
	КонецЕсли;

	Если НЕ Измерения.Найти("_all") = Неопределено Тогда
		Возврат ЗначенияСчетчика;
	ИначеЕсли НЕ Измерения.Найти("_no") = Неопределено Тогда
		Измерения = Новый Массив();
	КонецЕсли;

	АгрегатнаяФункция = ВРег(АгрегатнаяФункция);

	Если НЕ АгрегатныеФункции().Свойство(АгрегатнаяФункция) Тогда
		АгрегатнаяФункция = АгрегатныеФункции().Количество;
	КонецЕсли;
	
	ГруппыЗначений = Новый Соответствие();

	Для Каждого ТекЗначение Из ЗначенияСчетчика Цикл
		ИзмеренияСтрокой = "";
		Для Каждого ТекИзмерение Из Измерения Цикл
			Если ТекЗначение[ТекИзмерение] = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			ИзмеренияСтрокой = СтрШаблон("%1%2=%3;", ИзмеренияСтрокой, ТекИзмерение, ТекЗначение[ТекИзмерение]);
		КонецЦикла;
		Если ГруппыЗначений[ИзмеренияСтрокой] = Неопределено Тогда
			ГруппыЗначений.Вставить(ИзмеренияСтрокой, Новый Массив());
		КонецЕсли;
		ГруппыЗначений[ИзмеренияСтрокой].Добавить(ТекЗначение);
	КонецЦикла;

	АгрегированныеЗначения = Новый Массив();

	Для Каждого ТекЭлемент Из ГруппыЗначений Цикл
		Сумма = Неопределено;
		Мин = Неопределено;
		Макс = Неопределено;
		Количество = 0;
		Различные = Новый Соответствие();

		АгрегированноеЗначение = Новый Соответствие();
		Для Каждого ТекИзмерение Из Измерения Цикл
			АгрегированноеЗначение.Вставить(ТекИзмерение, ТекЭлемент.Значение[0][ТекИзмерение]);
		КонецЦикла;
		Для Каждого ТекЗначение Из ТекЭлемент.Значение Цикл
			Если ТипЗнч(ТекЗначение["_value"]) = Тип("Число") Тогда
				Сумма = ?(Сумма = Неопределено, ТекЗначение["_value"], Сумма + ТекЗначение["_value"]);
			КонецЕсли;
			Мин = ?(Мин = Неопределено, ТекЗначение["_value"], Мин(Мин, ТекЗначение["_value"]));
			Макс = ?(Макс = Неопределено, ТекЗначение["_value"], Макс(Макс, ТекЗначение["_value"]));
			Количество = Количество + 1;
			Различные.Вставить(ТекЗначение["_value"], 1);
		КонецЦикла;
		Если АгрегатнаяФункция = АгрегатныеФункции().Сумма Тогда
			АгрегированноеЗначение.Вставить("_value", Сумма);
		ИначеЕсли АгрегатнаяФункция = АгрегатныеФункции().Минимум Тогда
			АгрегированноеЗначение.Вставить("_value", Мин);
		ИначеЕсли АгрегатнаяФункция = АгрегатныеФункции().Максимум Тогда
			АгрегированноеЗначение.Вставить("_value", Макс);
		ИначеЕсли АгрегатнаяФункция = АгрегатныеФункции().Среднее Тогда
			Если ТипЗнч(Сумма) = Тип("Число") Тогда
				АгрегированноеЗначение.Вставить("_value", Сумма / Количество);
			Иначе
				АгрегированноеЗначение.Вставить("_value", Неопределено);
			КонецЕсли;
		ИначеЕсли АгрегатнаяФункция = АгрегатныеФункции().Различные Тогда
			АгрегированноеЗначение.Вставить("_value", Различные.Количество());
		Иначе
			АгрегированноеЗначение.Вставить("_value", Количество);
		КонецЕсли;

		АгрегированныеЗначения.Добавить(АгрегированноеЗначение);
	КонецЦикла;

	Возврат АгрегированныеЗначения;

КонецФункции // АгрегироватьЗначенияСчетчика()

// Функция - получает счетчик(и) для указанного списка описаний объектов
// по указанным настройкам счетчиков
//
// Параметры:
//   Объекты                    - Массив из Соответствие        - коллекция описаний объектов для получения счетчиков
//     * <Имя поля объекта>       - Строка, Число, Дата, Булево   - значение поля объекта
//   ПараметрыСчетчиковОбъекта  - Соответствие                  - настройки получения счетчиков для типа объектов
//                                                                (см. ПараметрыСчетчиков())
//   Счетчик                   - Строка                         - имя счетчика из настроек, если не указан,
//                                                                то возвращаются все счетчики, указанные в настройках
//
// Возвращаемое значение:
//   Соответствие                                         - значения счетчиков
//     * <Имя счетчика>         - Соответствие              - содержимое счетчика
//       ** description           - Строка                    - описание счетчика из параметров
//       ** values                - Массив из Соответствие    - значения счетчика
//          *** <Имя измерения>     - Строка                    - значение измерения счетчика
//          *** _value              - Число, Дата, Булево       - значение счетчика
//
Функция ЗначенияСчетчиков(Знач Объекты, Знач ПараметрыСчетчиковОбъекта, Знач Счетчик = "")

	ОписаниеСчетчиков = ПараметрыСчетчиковОбъекта["counters"];

	ИменаСчетчиков = "";

	Счетчики = Новый Соответствие();

	Для Каждого ТекСчетчик Из ОписаниеСчетчиков Цикл
		
		Если НЕ ТекСчетчик.Значение["use"] Тогда
			Продолжить;
		КонецЕсли;

		Если НЕ ВРег(ТекСчетчик.Ключ) = ВРег(Счетчик) И ЗначениеЗаполнено(Счетчик) Тогда
			Продолжить;
		КонецЕсли;
	
		ИмяСчетчика = ТекСчетчик.Ключ;
		ИмяИсточникаСчетчика = ИмяСчетчика;
		Если НЕ ТекСчетчик.Значение["name_rac"] = Неопределено Тогда
			ИмяИсточникаСчетчика = ТекСчетчик.Значение["name_rac"];
		КонецЕсли;

		ИменаСчетчиков = ИменаСчетчиков + ?(ИменаСчетчиков = "", "", ", ") + ИмяСчетчика;

		ОписаниеСчетчика = ТекСчетчик.Значение["description"];

		Счетчики.Вставить(ИмяСчетчика, Новый Соответствие());
		Счетчики[ИмяСчетчика].Вставить("description", ОписаниеСчетчика);
		Счетчики[ИмяСчетчика].Вставить("values", Новый Массив());

		Если Объекты = Неопределено Тогда
			ЗначениеСчетчика = Новый Соответствие();
			ЗначениеСчетчика.Вставить("_value", Неопределено);
			Счетчики[ИмяСчетчика]["values"].Добавить(ЗначениеСчетчика);
			Продолжить;
		КонецЕсли;

		Для Каждого ТекОбъект Из Объекты Цикл
		
			ЗначениеСчетчика = ЗначенияИзмеренийСчетчика(ПараметрыСчетчиковОбъекта, ТекОбъект, ТекСчетчик.Значение);

			ЗначениеСчетчика.Вставить("_value", ТекОбъект[ИмяИсточникаСчетчика]);

			Счетчики[ИмяСчетчика]["values"].Добавить(ЗначениеСчетчика);

		КонецЦикла;

		Счетчики[ИмяСчетчика]["values"] = АгрегироватьЗначенияСчетчика(Счетчики[ИмяСчетчика]["values"],
		                                                               ТекСчетчик.Значение["dimentions"],
		                                                               ТекСчетчик.Значение["aggregate"]);
	КонецЦикла;
	
	Если Объекты = Неопределено Тогда
		Сообщить(СтрШаблон("Отсутствуют данные для счетчиков ""%1""", ИменаСчетчиков), СтатусСообщения.ОченьВажное);
	КонецЕсли;

	Возврат Счетчики;

КонецФункции // ЗначенияСчетчиков()

// Функция - получает значения измерений указанного описания счетчика для переданного описания объекта
// по указанным настройкам счетчиков
//
// Параметры:
//   ПараметрыСчетчиковОбъекта  - Соответствие            - настройки получения счетчиков для типа объектов
//                                                          (см. ПараметрыСчетчиков())
//   Объект                     - Соответствие            - описание объекта для получения счетчиков
//   Счетчик                    - Соответствие            - описание счетчика из настроек
//
// Возвращаемое значение:
//   Соответствие                                 - значения измерений счетчика
//     * <Имя измерения>    - Строка          - значение измерения счетчика
//
Функция ЗначенияИзмеренийСчетчика(Знач ПараметрыСчетчиковОбъекта, Знач Объект, Знач Счетчик)

	ВсеИзмерения = ПараметрыСчетчиковОбъекта["dimentions"];

	ИзмеренияСчетчика = Счетчик["dimentions"];

	ЗначенияИзмерений = Новый Соответствие();
	
	Для Каждого ТекИзмерение Из ИзмеренияСчетчика Цикл

		ОписаниеИзмерения = ВсеИзмерения[ТекИзмерение];

		Если ОписаниеИзмерения = Неопределено Тогда
			ВызватьИсключение СтрШаблон("Для счетчика ""%1"" не найдено измерение ""%2""", Счетчик["name"], ТекИзмерение);
		КонецЕсли;

		ИмяИсточникаИзмерения = ТекИзмерение;
		Если НЕ ОписаниеИзмерения["name_rac"] = Неопределено Тогда
			ИмяИсточникаИзмерения = ОписаниеИзмерения["name_rac"];
		КонецЕсли;

		ЗначениеИзмерения = Объект[ИмяИсточникаИзмерения];

		ЗначенияИзмерений.Вставить(ТекИзмерение, ЗначениеИзмерения);

	КонецЦикла;
	
	Возврат ЗначенияИзмерений;

КонецФункции // ЗначенияИзмеренийСчетчика()

// Функция - преобразует переданные значения счетчиков в формат JSON
//
// Параметры:
//   Счетчики                 - Соответствие              - счетчики для преобразования
//     * <Имя счетчика>         - Соответствие              - содержимое счетчика
//       ** description           - Строка                    - описание счетчика из параметров
//       ** values                - Массив из Соответствие    - значения счетчика
//          *** <Имя измерения>     - Строка                    - значение измерения счетчика
//          *** _value              - Число, Дата, Булево       - значение счетчика
//
//   Префикс       - Строка           - строковый префикс счетчиков,
//                                      который будет добавлен к именам счетчиков в результате
//
// Возвращаемое значение:
//   Строка                 - значения счетчиков в формате JSON
//
Функция ФорматJSON(Счетчики, Префикс = "")

	Результат = Новый Соответствие();

	Для Каждого ТекСчетчик Из Счетчики Цикл

		ЗаголовокСчетчика = СтрШаблон("%1%2", Префикс, ТекСчетчик.Ключ);

		Результат.Вставить(ЗаголовокСчетчика, ТекСчетчик.Значение);

	КонецЦикла;

	Возврат ОбщегоНазначения.ДанныеВJSON(Результат);

КонецФункции // ФорматJSON()

// Функция - преобразует переданные значения счетчиков в формат Prometheus
//
// Параметры:
//   Счетчики      - Соответствие     - счетчики для преобразования
//   Префикс       - Строка           - строковый префикс счетчиков,
//                                      который будет добавлен к именам счетчиков в результате
//
// Возвращаемое значение:
//   Строка                 - значения счетчиков в формате Prometheus
//
Функция ФорматPrometheus(Счетчики, Префикс = "")

	Текст = Новый ТекстовыйДокумент();

	Для Каждого ТекСчетчик Из Счетчики Цикл

		ЗаголовокСчетчика = СтрШаблон("%1%2", Префикс, СтрЗаменить(ТекСчетчик.Ключ, "-", "_"));

		ОписаниеСчетчика = ТекСчетчик.Значение["description"];

		Текст.ДобавитьСтроку(СтрШаблон("# HELP %1 %2", ЗаголовокСчетчика, ОписаниеСчетчика));
		Текст.ДобавитьСтроку(СтрШаблон("# TYPE %1 gauge", ЗаголовокСчетчика));

		Для Каждого ТекЗначение Из ТекСчетчик.Значение["values"] Цикл

			ЗначенияИзмеренийСтрокой = "";
			ЗначениеСчетчика = Неопределено;
			Для Каждого ТекИзмерение Из ТекЗначение Цикл
				Если ВРег(ТекИзмерение.Ключ) = ВРег("_value") Тогда
					ЗначениеСчетчика = ТекИзмерение.Значение;
					Продолжить;
				КонецЕсли;

				ЗначениеИзмерения = ТекИзмерение.Значение;
				Если ТипЗнч(ЗначениеИзмерения) = Тип("Дата") Тогда
					ЗначениеИзмерения = Формат(ЗначениеИзмерения, "ДФ=yyyy-MM-ddThh:mm:ss");
				КонецЕсли;
				ЗначенияИзмеренийСтрокой = ЗначенияИзмеренийСтрокой +
				                           ?(ЗначенияИзмеренийСтрокой = "", "", ",") +
				                           СтрШаблон("%1=""%2""", СтрЗаменить(ТекИзмерение.Ключ, "-", "_"), ЗначениеИзмерения);
			КонецЦикла;

			Если НЕ ЗначениеЗаполнено(ЗначениеСчетчика) Тогда
				ЗначениеСчетчика = 0;
			КонецЕсли;
			Если ТипЗнч(ЗначениеСчетчика) = Тип("Число") Тогда
				ЗначениеСчетчика = Формат(ЗначениеСчетчика, "ЧРД=.; ЧН=; ЧГ=0");
			ИначеЕсли ТипЗнч(ЗначениеСчетчика) = Тип("Дата") Тогда
				ЗначениеСчетчика = Формат(ЗначениеСчетчика, "ДФ=yyyy-MM-ddThh:mm:ss");
			КонецЕсли;
			Текст.ДобавитьСтроку(СтрШаблон("%1{%2} %3",
			                               ЗаголовокСчетчика,
			                               ЗначенияИзмеренийСтрокой,
			                               ЗначениеСчетчика));
		КонецЦикла;

		Текст.ДобавитьСтроку("");

	КонецЦикла;

	Возврат Текст.ПолучитьТекст();

КонецФункции // ФорматPrometheus()

// Функция - преобразует переданные значения счетчиков в плоский (Plain) текстовый формат
//
// Параметры:
//   Счетчики      - Соответствие     - счетчики для преобразования
//   Префикс       - Строка           - строковый префикс счетчиков,
//                                      который будет добавлен к именам счетчиков в результате
//
// Возвращаемое значение:
//   Строка                 - значения счетчиков в плоском (Plain) текстовом формате
//
Функция ФорматPlain(Счетчики, Префикс = "")

	Текст = Новый ТекстовыйДокумент();

	Для Каждого ТекСчетчик Из Счетчики Цикл

		Для Каждого ТекЗначение Из ТекСчетчик.Значение["values"] Цикл
			
			ЗначениеСчетчика = ТекЗначение["_value"];
			
			Если НЕ ЗначениеЗаполнено(ЗначениеСчетчика) Тогда
				ЗначениеСчетчика = 0;
			КонецЕсли;
			
			Если ТипЗнч(ЗначениеСчетчика) = Тип("Число") Тогда
				ЗначениеСчетчика = Формат(ЗначениеСчетчика, "ЧРД=.; ЧН=; ЧГ=0");
			КонецЕсли;

			Текст.ДобавитьСтроку(СтрШаблон("%1%2=%3", Префикс, ТекСчетчик.Ключ, ЗначениеСчетчика));

		КонецЦикла;

	КонецЦикла;

	Возврат Текст.ПолучитьТекст();

КонецФункции // ФорматPlain()

// Функция - возвращает коллекцию возможных агрегатных функций
//
// Возвращаемое значение:
//   ФиксированнаяСтруктура     - возможные агрегатные функции
//
Функция АгрегатныеФункции()

	Значения = Новый Структура();
	Значения.Вставить("Сумма"     , "SUM");
	Значения.Вставить("Sum"       , "SUM");
	Значения.Вставить("Минимум"   , "MIN");
	Значения.Вставить("Min"       , "MIN");
	Значения.Вставить("Максимум"  , "MAX");
	Значения.Вставить("Max"       , "MAX");
	Значения.Вставить("Среднее"   , "AVG");
	Значения.Вставить("Avg"       , "AVG");
	Значения.Вставить("Количество", "COUNT");
	Значения.Вставить("Count"     , "COUNT");
	Значения.Вставить("Различные" , "DISTINCT");
	Значения.Вставить("Distinct"  , "DISTINCT");

	Возврат Новый ФиксированнаяСтруктура(Значения);

КонецФункции // АгрегатныеФункции()

// Функция - возвращает коллекцию возможных форматов результата
//
// Возвращаемое значение:
//   ФиксированнаяСтруктура     - возможные форматы результата
//
Функция ФорматыРезультата()

	Значения = Новый Структура();
	Значения.Вставить("Json"      , "JSON");
	Значения.Вставить("Prometheus", "PROMETHEUS");
	Значения.Вставить("Plain"     , "PLAIN");

	Возврат Новый ФиксированнаяСтруктура(Значения);

КонецФункции // ФорматыРезультата()

#КонецОбласти // СлужебныеПроцедурыИФункции

Инициализировать();
